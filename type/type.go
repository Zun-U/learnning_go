package learn_type

import (
	"fmt"
)

func TypeMain() {
	fmt.Println("Chapter2 primitive type and variable")

	// 論理型
	fmt.Println(flag, ":論理型のゼロ値(宣言されたが値が割り当てられていない変数)は、『false』")
	fmt.Println(isAwsome)

	// 整数型
	fmt.Println(integerType, ":整数型のゼロ値は『0』")

	// 整数リテラルのデフォルトの型
	fmt.Printf("%v:%T  整数リテラルのデフォルトは「int」型\n", intLiteralDefault, intLiteralDefault)

	// 結果を同じ変数に代入
	reAssignmentInt()

	// 浮動点小数点のゼロ値
	fmt.Printf("%v:%T  :浮動小数点型のゼロ値は『0』\n", xf, xf)

	// 浮動小数点数リテラルのデフォルトの型
	fmt.Printf("%v:%T  浮動小数点数リテラルのデフォルトは「float64」型\n", xft, xft)

	// 文字列のゼロ値は「""」
	fmt.Printf("%v:%T  :文字列のゼロ値は『\"\"』(空文字列)\n", StringZeroValue, StringZeroValue)

	// runeリテラルのデフォルトの型
	fmt.Printf("%v:%T  :runeリテラルのデフォルトの型は「rune」型\n", RuneDefaultType, RuneDefaultType)

	// 文字列リテラルのデフォルトの型
	fmt.Printf("%v:%T  :文字列リテラルのデフォルトの型は「string」型\n", StringDefaultType, StringDefaultType)

	// 型変換
	TypeChange()
}

// ❐ 基本型(primitive type) ❐
//
// 4つの型がある。
// ・論理型
// ・整数型
// ・浮動小数点型
// ・文字列型

// ❐ ゼロ値　❐
//
// 「宣言されたが値が割り当てられていない変数」に対してデフォルトのゼロ値(zero value)が割り当てられる。

// ❐　リテラル　❐
//
// 数値や文字、文字列などをじかに示したもの
// Goでは4種類ある

//　1.整数リテラル
// 通常は10進数として表す
// 他には「0b」を頭に置くことで2進数(binary)、「0o」で8進数(octal)、「0x」で16進数(hexadeciaml)を表せる
//
// Goでは整数リテラルの任意の箇所にアンダースコア「_」を書ける
// 例)「1_234」
// ※「1_2_3_4」は読みにくくなるから推奨しない
//
// ☆☆ アンダースコア「_」は10進数を3桁ごとに区切るのに用いたり、2,8,16進数で2文字、4文字ごとに区切るのに用いることが推奨される ☆☆

// 2.浮動小数点リテラル
// 「3.14」や「6.03e23」の様な指数を使った表記も可能
//
// 「0x」を頭につけることで16進数で表現できる
//
// 整数リテラル同様、浮動小数点リテラルでも桁を区切る目的で「_」が使える

// 3.runeリテラル
// 文字を表す
//
// ☆　先頭と最後にシングルクォテーション「'」を置く ☆
//
// runeリテラルは次の形式で表現される
//
// ・1文字のUnicode文字 (例：'a')
// ・8ビット8進数 (例：'\141')
// ・8ビット16進数 (例：'\x61')
// ・16ビット16進数 (例：'\u0061')
// ・32ビット Unicode (例：'\U00000061')
//
// この他に、バックスラッシュ「\」でエスケープされたruneリテラルもある
// 主なものは
//
// ・改行 ('\n')
// ・タブ ('\t')
// ・一重引用符 ('\'') ※シングルクオート
// ・二重引用符 ('\"') ※ダブルクオート
// ・バックスラッシュ ('\')

// 4.文字列リテラル
//
// 文字列リテラルを表すのに2つの方法がある
//
// 〇 解釈済みの文字列リテラル (interpreted string literal)
// ◇ 生(ロー)文字列リテラル (raw string literal)
//
//　ほとんどの場合は「"」の組を使って「解釈済み文字列リテラル」を作る
// この場合は0個以上のruneリテラルを含むことができる
// ここで使えない文字は、エスケープされていない「\」、改行、それに「"」がある
//
// ☆ 解釈済み文字列リテラルを使って2行にわたる文字列を表示したい場合は、「\n」を使って改行する必要がある
//
//
// 文字列中に「\」、改行、「"」を含めたい場合は、「`」(バッククォート)で囲まれた生(ロー)の文字列リテラルを使用する
// ロー文字リテラルには「`」(バッククォート)以外の任意の文字を含めることができる
// 次のようにすることで改行や二重引用符を文字列中に書くことができる

// *************************************************
// GOの言語使用により、ソースコードは常にUTF-8で書かれる
// 16進数のエスケープを使わない限り、文字列リテラルUTF-8で書かれる
// *************************************************

// ❐ リテラルと型 ❐
//
// ・サイズの異なる整数については、加算さえもできない
// ・一方、整数リテラルを「浮動小数点数」の式で使ったり、整数リテラルを「浮動小数点数」の変数に代入できる
//
// ☆ Go言語において、リテラルは『型がない(untype)』ためで、"リテラルと『互換性を持つ』任意の変数に代入できる"
//
// ・ただし、「文字列リテラル」を数値型の変数に代入できないし、「数値リテラル」を文字列の変数に代入することもできない。
//
// ☆ リテラルが型を持たないのは、GO言語がプログラマーが型を指定するよう設計されている為（プログラミングがしやすい）
//
// ・指定された変数をあふれさせてしまうようなリテラルは、コンパイル時にエラーになる
// 例)「1000」をbyte型の変数に代入しようとするとエラーになる
//
// ★ 型が明示的に宣言されない場合がある。この場合は、リテラルに対して『デフォルトの型』が使用される。

//
// -*-*-*-*-*-*-*- 型(type) -*-*-*-*-*-*-*-
//

// ❐❐　論理型bool　❐❐
// 真偽値(論理値、bool値)を持つ変数の型は、論理型(boolean)になる
//
// ・ 論理型の変数は「true」「false」のいずれかの値を持つ
// ・ boolのゼロ値は『false』
//
// 例)
var flag bool // 値が代入されないとfalseになる。
var isAwsome = true

//
// ☆ 変数の型の多くの場合は、変数の宣言で決まる

// ❐❐　数値型　❐❐
// GOには「12種類」の数値を表す型がある
// これらは「3つのグループに分けられる」
//
// :::::: 整数型 ::::::
// Go言語で整数を表す型には、1バイトから4バイトまでの大きさの、『符号付き』の整数と『符号なしの整数』がある
//
// 「符号付き整数」
// int8    -128 ~ 127
// int16   -32768 ~ 32767
// int32   -2147483648 ~ 2147483647
// int64   -9223372036854775808 ~ 9223372036854775807
//
// 「符号なし整数」
// unit8	  0 ~ 255
// uint16   0 ~ 65535
// uint32   0 ~ 4294967295
// uint64   0 ~ 18446744073709551615
//
// ☆ すべての整数型のゼロ値は『0』
var integerType int // ゼロ値は『0』
// ◇ 特別な整数型 ◇
//
// 整数型の中に特別な名前を持つ物がある
//
// ・「byte」  --unit8の別名(※別名のことを『エイリアス』という)
// ・「int」   --CPUによって64ビットあるいは32ビットになる(int64あるいはint32と『同じサイズ』)
// ・「uint」  --intの符号がないもの(0以上)
// ・「rune」  --ひとつのコードポイントを表現する
// ・「uintptr」  --メモリを操作して、C言語の様なポインタ操作などを可能にするためのもの
//
// 「byte」はuint8のエイリアスで、byteとuint8の間の代入、比較、数値演算が可能。
// しかし、uint8は"めったに"使われない
//
// ☆☆ byteを使用するのが一般的
//
// 「int」は32ビットのCPUにおいては、32ビットの符号付き整数となるため、この場合のintは「int32」と同じサイズになる
// ほとんどの64ビットのCPUにおいては、intは64ビットの符号付き整数となるので、「int64」と同じサイズになる
// intは「プラットフォームによって大きさが異なることになる」ので、intと、int32やint64の間の代入、比較、数値演算は型変換しない限りコンパイル時にエラーとなる
//
// ☆☆　整数リテラルはデフォルトでint型となる　☆☆
var intLiteralDefault = 1

// ◇ 整数型の選択 ◇
//
// 整数型選択するための単純なルール
//
// ・ 「特定の大きさ」と「特定の符号の整数バイナリファイル」あるいはネットワークプロトコルを処理しているのならば、対応する整数型を使う
// ・ すべての整数型について機能するライブラリ関数を書く場合は2つの関数を書く。一つは引数と戻り値が「int64」のもの、もう一つが「uint64」のもの
// ・ その他の場合は「int」を使用する
//
// ☆ パフォーマンスや他のシステムの統合といった目的で、符号の有無やサイズについて明示する必要があるという場合を除けば、
// ☆ 「int型」を使うのが良い
// ☆ 理由なく他の型を使うのは「早すぎる最適化」

// ◇ 整数関連の演算子 ◇
//
// Go言語では、「+」「-」「*」「/」の四則演算子と、剰余(あまり)を計算する「%」の各演算子が使える
//
// ・ 「整数」の割り算の結果は、「整数」になる
// ・ 「浮動小数点数」の結果が欲しい場合は、型変換をして「浮動小数点数」に変換してから計算する
//
// ★ 「0」による割り算をしてしまうと『パニック』になるので避ける
// ※ 「整数」の割り算は「0」の方向に丸められる
//
// ある変数に対して、演算を行って「結果を同じ変数に代入」する場合は。「+=」「-=」「*=」「/=」「%=」の各演算子が使える
func reAssignmentInt() {

	var x int = 10

	x *= 2 // 関数内でのみ書ける書き方

	fmt.Printf("%v:%T 演算を行って結果を同じ変数に代入\n", x, x)

}

//
// ・ 「整数」の比較には「==」「!=」「>」「>=」「<」「<=」を使う
//
// ・ 「整数」に"対して"はビット演算を行うことができる
//
// ・   左シフトは「<<」、右シフトは「>>」で行う
//
// ・   ビット単位の「&」(AND)、「|」(OR)、「^」(XOR)、「&^」(AND NOT)の各演算も可能
//
// ☆★☆ 算術演算子と同様、「=」の前に演算子を置いて『左辺の変数に対する演算と代入』ができる
//       「&=」「|=」「^=」「&^=」「<<=」「>>=」

// ❐ 浮動点小数点 ❐
//
// # Go言語の浮動点小数点は「float32」と「float64」の2種類がある
//
// ☆ 整数型と同様、浮動小数点型のゼロ値は「0」
var xf float64

// ☆ 浮動小数点数リテラルのデフォルトの型は「float64」
var xft = 3.14

//
// ※ 浮動小数点数の扱いは『IEEE 754』に準拠している
//
//
// ・ 既存のフォーマットとの互換性を気にする必要が無ければ、「float64」を使用する
//
//
// ・ 浮動小数点数リテラルのデフォルトの型が「float64」なので、 『いつもfloat64』というのが最も簡単な選択
// ☑ float32は10進数で6~7桁の精度しかないので、『精度を考えても』float64を推奨する
//
// ※※　そもそも、浮動小数点数を使う必要があるか要検討する　※※
// -- ほとんどの場合、その必要がない
//
//
// ・ Goにおいて、浮動点小数点があらわす範囲が広く、あくまで『近似値』でしかない
// (グラフィクスや物理計算などの誤差があっても許容される場合)
//
// ☑ 浮動小数点数は、『10進数を正確に表現できない』
//    金額など誤差なしで10進数を表現しなければならない場合には「使わない」
//
// ・ 浮動小数点数については、標準的な四則演算子や比較演算子が使える(「%」を除く)
//
// 割り算についてはいくつか留意する点がある
// -- 非ゼロの浮動小数点数を「0」で割ると、+Inf、または-Inf(正あるいは負の無限大)になる
// -- 0が記憶された浮動小数点数型の変数を「0」で割ると「NaN」(Not a Number)になる
//
//
// ☆★☆ 浮動小数点数は常に「近似値」
//       その為、比較ではなく2つの浮動小数点数の差が『一定の範囲内に収まっているか』を判定する
// ※ 『一定の範囲』どのくらいにするべきかは求められる精度に依存する(この範囲のことを"イプシロン"と呼ぶ場合がある)

// 複素数型
//
// 大規模なプログラムの一部でマンデルブロ集合を計算する必要や、二次方程式を解く必要があるといった場合の為、Go言語では複素数の計算はできるようになっている

// ❐❐　文字列型とrune型　❐❐
//
// 文字列のゼロ値は「""」(空文字列:くうもじれつ)
var StringZeroValue string

// ・ GoはUnicodeをサポートしているため、文字列にUnicode文字を含めることができる
//
// ☆ 整数や浮動小数点数と同様に、
//
//	--文字列の比較にも「==」あるいは「!=」を用いる
//	--順序の比較には「>」「>=」「<」「=<」を用いる
//
// 　 --文字列連結には演算子『+』を用いる
//
// ★★ Goの文字列はイミュータブル(変更不可能)である
//
//	したがって、文字列型の変数に現在記憶されているものとは『別の値を代入する』ことはできるが、
//	そうした変数に代入された『文字列の値』を変えることはできない
var ImutableWords string = "文字列はイミュータブルである。"

// ☆★ Go言語にはひとつの「コードポイント」を表現する型であるrune型もある
//
//	:::: 「rune」型は「int32」の別名(エイリアス)
//	runeリテラルのデフォルトの型はrune
//	そして、文字列リテラルのデフォルトはstring(文字列)
var RuneDefaultType = 'a'
var StringDefaultType = "a"

//
//
// ※ コードポイントは、 (Unicode などの) テキストを表現するシステムにおいて、抽象文字を表現するために割り当てられた番号のこと
//
//
// ☆☆☆ 文字列を参照している場合は、「int32」ではなく「rune」を使用する
//        ※ コンパイラにとっては同じかもしれないが、『コードの意図が明確になる』

// ❐❐　明示的型変換　❐❐
//
// Goは明快さと可読性に重きを置く言語のため、変数間の『暗黙的』型変換は "行わない"
//
// ★★ 型が違う場合は、必ず型変換を行う
//
//	整数や浮動小数点数で『サイズが異なる "だけ" 』の場合も変換が必要
func TypeChange() {

	var x int = 10 // 整数型
	fmt.Printf("%v:%T 整数型\n", x, x)

	var y float64 = 30.2 // 浮動小数点数型
	fmt.Printf("%v:%T 浮動小数点型\n", y, y)

	var z float64 = float64(x) + y // 変数x(整数型)を浮動小数点数型に型変換

	var d int = x + int(y) // 変数y(浮動小数点数型)を整数型に型変換

	fmt.Printf("%v:%T, %v:%T\n", z, z, d, d)
}

// 型に対するこのような厳密さは、bool(論理型)についても適用される
//
// ☆☆☆☆☆ Goの型変換はすべて明示的に行われる為、論理型以外の型の変数などを論理型として扱う事は出来ない
// 　　　　　 ※ 多くの言語では非ゼロの数値や、空でない文字列を『true』として扱うことができるがGoはそうではない
//
// ★★★★★ 論理型に変換できるのは論理型しかない ★★★★★
//
// ※ 他のデータ型を『論理型』に変換したい場合は、比較演算子を用いるしか方法がない
//    xが0と等しいかどうか判定する方法は「X == 0」しかないし、文字列sが空文字列かを判定する方法は「s == ""」しかない
//
// Goでのこのような型変換は、単純さと明快さを得るために、冗長さを招いている点だと言える
// Goではこのような「トレードオフ」をいくつか有している
//
// ★ Goでは簡潔さよりも理解しやすさに重きが置かれている
