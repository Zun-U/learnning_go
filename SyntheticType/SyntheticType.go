package synthetictype

import (
	"fmt"
)

func  SyntheticTypeMain() {

	fmt.Println("======== 合成型 ========")
	// 『合成型』--「複合データ型」、あるいは「コンテナ型」とも呼ばれる

	// 配列の宣言方法
	fmt.Printf("%v:%T\n", xa, xa)

	// 値を指定した配列の宣言
	fmt.Printf("%v:%T\n", xar, xar)

	// 途中に空きがある配列の宣言
	fmt.Printf("%v:%T\n", xarr, xarr)

	// 配列の初期化
	fmt.Printf("%v:%T\n", xarra, xarra)

	// 配列の比較(「==」と「!=」が使える)
	fmt.Println(ax == ay)

	// 疑似多次元配列
	fmt.Println(xaaa)

	// 配列のインデックスを指定して値を代入
	AssignmentArray()
}

// ❐❐❐　配列　❐❐❐
//
// Go言語にも配列(array)があるが、配列が直接使われることは多くない
//
// ◇◆◇　配列の宣言方法　◇◆◇
// 『配列の各要素は "指定された型" でなければいけない』(ただし、全要素が常に同じ型だということは意味しない)
// いくつか宣言方法があるが、最初の形式は、次のように『配列の大きさ』と『要素の型』を指定するもの
var xa [3]int // [3] => 配列の大きさ、　int => 要素の型
// ・この宣言で３つの整数を持つ配列が生成される
// ・値が指定されていないので、すべての要素はintのゼロ値(すなわち「0」)を持つ
//
// 値を指定する場合は、次のように「配列リテラル」を用いる
var xar = [3]int{10, 20, 30} // 「10」「20」「30」が配列リテラルに当たる
//
// 途中に「空き」がある配列の値を指定したい場合は、配列のインデックス(添字)とその値を次のように指定する
var xarr = [12]int{1, 5: 4, 6, 10: 100, 15}
//
// 配列の初期化に配列リテラルを使う場合は、大きさを表す整数の代わりに「...」が使える
var xarra = [...]int{10, 20, 30}
//
// ☆「==」と「!=」を使って配列の比較ができる
var ax = [...]int{1, 2, 3}
var ay = [3]int{1, 2, 3}
//
// ☆◆☆ Go言語には一次元配列しかないが、次のようにして多次元配列のように使うことができる ☆◆☆
var xaaa [2][3]int //[[0, 0, 0], [0, 0, 0]]　★[0, 0, 0]が型になる
// これにより、長さ『2』の配列になるが、その型は長さ3の整数配列ということになる
//
// 多くの言語と同様、次のようにインデックスを使用する
func AssignmentArray(){

	var x [3]int

	x[0] = 10 // 先頭要素として10を代入

	fmt.Println(x[0])

}
//
//
// 最後の要素を超えるインデックスを指定したり、インデックスとして負の値を