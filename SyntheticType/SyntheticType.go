package synthetictype

import (
	"fmt"
)

func SyntheticTypeMain() {

	fmt.Println("======== 合成型 ========")
	// 『合成型』--「複合データ型」、あるいは「コンテナ型」とも呼ばれる

	// 配列の宣言方法
	fmt.Printf("%v:%T\n", xa, xa)

	// 値を指定した配列の宣言
	fmt.Printf("%v:%T\n", xar, xar)

	// 途中に空きがある配列の宣言
	fmt.Printf("%v:%T\n", xarr, xarr)

	// 配列の初期化
	fmt.Printf("%v:%T\n", xarra, xarra)

	// 配列の比較(「==」と「!=」が使える)
	fmt.Println(ax == ay)

	// 疑似多次元配列
	fmt.Println(xaaa)

	// 配列のインデックスを指定して値を代入
	AssignmentArray()

	// 組み込み関数(len)を使用して、配列の長さを調べることができる
	fmt.Println(len(xa))

	fmt.Println("======== Slice ========")
	// スライスの宣言
	fmt.Printf("%v:%T\n", xtr, xtr)

	// インデックスを指定したスライスリテラルを用いた宣言
	fmt.Println(xtrtr)

	// インデックスを指定して要素の値を変更、取得
	SliceIndex()

	// 多次元スライス
	fmt.Println(xslice)

	// スライスの初期値はnil
	fmt.Println(xsliceZero)

	// スライスの比較はnilかどうかしか行えない
	fmt.Println(xsliceZero == nil) // true

	// スライスに要素の追加、「append」
	SliceAppend()

	// すでに値が入っているスライスに「append」
	SliceAppendVal()

	// 複数の要素の値の追加
	MultiSliceAppend()

	// スライスに別のスライスの全要素を追加する
	SliceAppendSlice()

	// Len & Cap
	LenAndCap()

	// Make
	MakeExp()

	// Fale make pattern
	FailMakePattern()

	// Make specify cap
	MakeCap()

	// Make size 0 slice
	MakeSize0()

	// Nil Slice with var
	NilSlice()

	// Emptry slice (not nil)
	EmptySlice()

	// Slice literal
	SliceLiteral()

	//Fail append pattern
	FailMakeSliceAppend()

	// Slice of slice(Sub Slice)
	SliceOfSlice()

	// SubSlice share memory
	SubSliceShareMemory()

	// SubSlice Complex
	MultiSubSliceAppendComplex()

	// Full Slice
	FullSlice()

	// Array Slice
	ArraySlice()

	// Copy Slice
	CopySlice()

	// Copy Peace Of Slice
	CopyPeaceOfSlice()
}

// ❐❐❐　配列　❐❐❐
//
// # Go言語にも配列(array)があるが、配列が直接使われることは多くない
//
// ◇◆◇　配列の宣言方法　◇◆◇
// 『配列の各要素は "指定された型" でなければいけない』(ただし、全要素が常に同じ型だということは意味しない)
// いくつか宣言方法があるが、最初の形式は、次のように『配列の大きさ』と『要素の型』を指定するもの
var xa [3]int // [3] => 配列の大きさ、　int => 要素の型
// ・この宣言で３つの整数を持つ配列が生成される
// ・値が指定されていないので、すべての要素はintのゼロ値(すなわち「0」)を持つ
//
// 値を指定する場合は、次のように「配列リテラル」を用いる
var xar = [3]int{10, 20, 30} // 「10」「20」「30」が配列リテラルに当たる
// 途中に「空き」がある配列の値を指定したい場合は、配列のインデックス(添字)とその値を次のように指定する
var xarr = [12]int{1, 5: 4, 6, 10: 100, 15}

// 配列の初期化に配列リテラルを使う場合は、大きさを表す整数の代わりに「...」が使える
var xarra = [...]int{10, 20, 30}

// ☆「==」と「!=」を使って配列の比較ができる
var ax = [...]int{1, 2, 3}
var ay = [3]int{1, 2, 3}

// ☆◆☆ Go言語には一次元配列しかないが、次のようにして多次元配列のように使うことができる ☆◆☆
var xaaa [2][3]int //[[0, 0, 0], [0, 0, 0]]　★[0, 0, 0]が型になる
// これにより、長さ『2』の配列になるが、その型は長さ3の整数配列ということになる
//
// 多くの言語と同様、次のようにインデックスを使用する
func AssignmentArray() {

	var x [3]int

	x[0] = 10 // 先頭要素として10を代入

	fmt.Println(x[0])

}

//
//
// 最後の要素を "超える" インデックスを指定したり、インデックスとして "負の値" を指定したりは出来ない
// 定数あるいはリテラルでこのような指定をした場合は、コンパイル時のエラーになる
//
// ★ インデックスを変数で指定した場合にはコンパイルされるが、値が範囲外になると実行に失敗し、「パニック」となる
//
// 組み込みの関数lenを使って、配列の長さ(大きさ、length)を調べることができる
//
//
// Goでは「配列が直接使われる事は多くない」と書いたが、その理由は「配列にはかなりの制限がある」から
//
// ☆★☆ Goでは配列の大きさを配列の「型」の一部としてみなす
//       つまり、[3]intと宣言した配列と、[4]intと宣言した配列では "型が異なる"
//       ※これは、配列の大きさを指定するのに変数を使えないことを意味する
//			 ◆◇◆ 配列の型は、コンパイル時に決定できなければいけない
//
// 長さが異なる配列への型変換もできない
// 異なる長さの配列を相互に変換できない為、任意の長さの配列を扱う関数が書けない
// さらには、一つの変数に異なる長さの配列を代入することはできない
//
// ☆★ このような制限がある為、配列を使うのは事前にサイズの分かる場合のみになります
// ※配列は、Goでよく使われる「スライス」の「後方支援」の為存在している

// ❐❐❐　スライス　❐❐❐
//
// 一連の値を保持する為のデータ構造が必要なら、ほとんどの場合は「可変長の配列」ともいえる『スライス(slice)』を使うのが正解
// スライスの型にはサイズ(長さ)が含まれないため、配列の様な制限はない
//
// 任意サイズのスライスを処理する関数をかけるし、スライスのサイズは必要に応じて変化する
//
// スライスが配列と大きく異なるところは、『宣言時に大きさを指定しない』
var xtr = []int{10, 20, 30} // スライスリテラルを使用して、3個の整数からなるスライスを生成
// [n]あるいは[...]と書くと配列になる。(nは正の整数)
// []だけ書くとスライスになる
//
// 配列リテラル同様、スライスリテラルでもインデックスを指定して要素の一部の値だけを指定できる
var xtrtr = []int{1, 2, 5: 4, 6, 7, 10: 100, 5}

// 配列同様、次のようにインデックスを指定して要素の値の取得や変更ができますが、「インデックスの範囲を超える要素の読み書きは "できない"」
func SliceIndex() {

	var x = []int{1, 2, 3}

	x[0] = 10

	fmt.Println(x[0])

}

// また、配列同様、多次元のスライスをシミュレートすることができる
var xslice [][]int

// リテラル以外を使ってスライスを宣言すると、配列との違いがよくわかる
var xsliceZero []int // スライスのゼロ値、すなわち「nil」が初期値になる(nilに初期化される)
//
// 値が一つも代入されていないスライスは、スライスのゼロ値、すなわち「nil」が挿入される
// Goにおいて「nil」はいくつかの型において『値がない』事を示す識別子となる
//
// ★☆★ 数値定数と同様、『nilには型がない』
// 　　　 従って、異なる方に代入したり、異なる方と比較したりできる
//
// ◇◆◇ スライスは「比較可能」では "ない"
//       2つのスライスが同じか違うかを判定するのに、「==」や「!=」を使うとコンパイル時のエラーになる
// 　　　 ※ スライスと比較できるのは「nil」だけ
//

// ❐　len　❐
//
// 関数「len」で配列の長さ(サイズ)が分かるが、この関数はスライスにも使える
// そして、nilスライスを「len」に渡すと0を返す

// ❐　append　❐
//
// スライスの要素を増やすには、関数「append」を使用する
func SliceAppend() {

	var x []int

	x = append(x, 10) // 「nil」の後ろに要素の追加

	fmt.Println(x)

}

// 「append」には少なくとも2個の引数(任意の型のスライスと『同じ型』の値)をしていする
//
// ☆ 戻り値は『同じ型のスライス』になる
//
// 第1引数に指定されたスライスにappendの結果が代入されている
// 上記の例では「nil」スライスの後ろに追加されているが、次の例のようにすでに要素があるスライスの『最後尾』への追加もできる
func SliceAppendVal() {

	var x = []int{1, 2, 3}

	x = append(x, 4) // 最後尾へ要素の追加

	fmt.Println(x)

}

// 複数の値も追加できる
func MultiSliceAppend() {

	var x = []int{1, 2, 3}

	x = append(x, 4, 5, 6)

	fmt.Println(x)

}

// ☆ 演算子「...」を使うことでスライスの個々の値を展開することができ、これを使うことでスライスの後に『別のスライスの全要素』を追加できる
func SliceAppendSlice() {

	x := []int{2, 3, 4}

	y := []int{20, 30, 40}

	x = append(x, y...) // 「y...」でスライス「y」をスライス「x」の要素の最後尾に追加している

	fmt.Println(x)

}

//
// ☆★☆ 「append」の戻り値を変数に代入したりせずに無視すると、コンパイル時のエラーになる
// 				「=」の左辺と右辺の両方にxを書かなければならないのは面倒だと思うかもしれないが、Go言語は「値呼び出し」の言語
// 				❐❐❐ 関数に引数を渡す際には、 "必ず" 『値のコピーが作られてから』渡される
//
// ※※※ 「append」にスライスを渡す際にも、実際に渡されるのは『コピー』
//        「append」はスライスのコピーに値を追加したものを返す
// 				従って、変数の後ろに値を追加したい場合は、戻された結果を。改めてその変数に代入することになる

// ❐ スライスのキャパシティ ❐
//
// ☆ スライスは値が連続したもの
// ☆☆		スライスの各要素はメモリ内の連続した領域に記憶されることで、素早い読み書きができるようになってる
//
// 　　★ 各スライスはキャパシティ(容量)を持っている
// ◆--◆ 『あらかじめ』、一定個の連続する領域が確保されているのである ◆--◆
// 　　　　この値はlen関数が返す値よりも大きい場合がある
//
// スライスに「append」を行うと、一個以上の値がスライスの最後に追加される
// 関数「len」の値は、値が一つ追加されるごとに1ずつ増えていく
//
// ★★★　「len」の値がキャパシティ(容量)に達するとそれ以上記憶できなくなる
//
//	☆☆☆ このような状態で『さらに』値を追加しようとするとGoのランタイムがより大きなキャパシティを持つスライスの領域を確保する。
//
// 　　　　最初のスライスのすべての値が新しいスライスにコピーされたうえで、「append」に指定された値が最後に追加され、
// 　　　　その結果できた新しいスライスが「append」から『戻される』ことになる
//
// 📝 Goのランタイム
//
//		高レベルの言語はすべて、プログラムの実行の為に一群のライブラリにいぞんしており、Go言語もその例外ではない
//		Goのランタイムはメモリの確保(アロケーション)やガベージコレクション、並行性のサポート、ネットワーキング、組み込みの型や関数の実装などのサービスを提供している
//		Goのランタイムは、すべてのGoのバイナリファイルに『コンパイル時』に組み込まれる
//		☆ バイナリにランタイムが含まれている為Goのプログラムは簡単に配布できる
//
//	「append」によってスライスが大きくなってくると、コピーの為に時間がかかるようになる
//
// (以前確保されていたメモリのガベージコレクションも必要になる)
// ☆ この為Goのランタイムはスライスのサイズを増やす際には、ある程度の余裕をもってメモリを確保する
//
// ※ Go1.17の段階でのルールはキャパシティが1,024未満の場合は2倍にし、それ以降は25％以上増やすというものになっていた
//
// 「len」はスライスの "現在" のサイズを返すが、組み込み関数「cap」はスライスの現在のキャパシティを返す
// 「len」よりも使われる頻度は少ないだろうが、新しいデータを保持するのに十分なサイズがあるか確認したい場合は「cap」が使える
//
// ☆★ 関数「cap」の引数として配列を渡すこともできるが、この場合は「cap」の値と「len」の値は同じになる
func LenAndCap() {
	var x []int
	fmt.Println(x, len(x), cap(x)) // [] 0 0
	x = append(x, 10)
	fmt.Println(x, len(x), cap(x)) // [10] 1 1
	x = append(x, 20)
	fmt.Println(x, len(x), cap(x)) // [10 20] 2 2
	x = append(x, 30)
	fmt.Println(x, len(x), cap(x)) // [10 20 30] 3 4 >>> 「2」のcap(容量)を超えたため、その2倍の「4」のcapがメモリ確保のため割り当てられた
	x = append(x, 40)
	fmt.Println(x, len(x), cap(x)) // [10 20 30 40] 4 4
	x = append(x, 50)
	fmt.Println(x, len(x), cap(x)) // [10 20 30 40 50] 5 8　>>> 「4」のcap(容量)を超えたため、その2倍の「8」のcapがメモリ確保のため割り当てられた

}

//
// スライスが自動的にキャパシティを増やしてくれるのは悪いことではないが、
// あらかじめ『最大のサイズ』が分かっているのなら、それを指定しておいた方が効率的である
// このためには『make』を使う

// ❐ make ❐
//
// これまで見たスライスの宣言方法ではキャパシティをあらかじめ指定することはできないが、
// 「make」を使えば型や長さ、それに(オプションで)キャパシティを指定できる
func MakeExp() {

	x := make([]int, 5)

	fmt.Println(x, len(x), cap(x)) // [0 0 0 0 0] 長さ：5 キャパシティ：5　のintのスライス

	// ☆ 長さは「5」なので、x[0]やx[4]といった表現は有効で、いずれも値として「0」を持っている

}

// 「make」を使って生成した配列の要素に値を入れるのに「append」を使用する初心者がいるが、それは誤り
func FailMakePattern() {

	x := make([]int, 5)
	fmt.Println(x, len(x), cap(x)) // [0 0 0 0 0] 5 5

	x = append(x, 10)
	fmt.Println(x, len(x), cap(x)) // [0 0 0 0 0 10] 6 10

	// このコードを実行すると、x[4]の後に新たな要素が追加されることになるから、xの値は
	//
	// 0|1|2|3|4|5
	// 0|0|0|0|0|10
	//
	// となる
	// このとき、len(x)は6、cap(x)は10になる
}

// こんどは「make」にキャパシティを指定する
func MakeCap() {

	x := make([]int, 5, 10) // 「長さ:5、キャパシティ:10」を指定してのスライスを作成

	fmt.Println(x, len(x), cap(x)) // [0 0 0 0 0] 5 10

}

// 次のようにすることで、長さ「0」、キャパシティ「10」のスライスを生成する
func MakeSize0() {

	x := make([]int, 0, 10)
	fmt.Println(x, len(x), cap(x)) // [] 0 10

	// ☆☆☆ この場合キャパシティは「10」だが、長さは「0」の為x[0]、x[1]などの要素の指定はできない

	// ☆ ただし、次のようにappendを使用して要素の追加はできる

	x = append(x, 5, 6, 7, 8)
	fmt.Println(x, len(x), cap(x)) // [5 6 7 8] 4 10
	// xの値は[5, 6, 7, 8]になり、長さは『4』に代わる
	// ※キャパシティは『10』のまま

}

// ◇◆◇　キャパシティとして長さよりも小さな値を(数値リテラルあるいは定数を使って)指定するとコンパイル時のエラーになる
// 				例)　x := make([]int, 5, 1) ⇒ コンパイル時にエラーになる
// 	　　　※※※　長さよりも小さな値を持つ『変数』を使ってキャパシティを指定すると実行時に『パニック』となる

// ❐ スライスの生成方法の選択 ❐
//
// ここまで、いろいろな生成方法をみたが、実践ではどの方法を使えばよいか
//
// ここで考えなければならないのは『どうすればスライスを大きくする回数を減らせるか』である
//
// ⅰ.スライスが全く大きくならない可能性があるのならば、次のように「var」と「nil」スライスを使いのが良い
func NilSlice() {

	var data []int // スライスのゼロ値『nil』で初期化される(nilスライス)

	// 『nil』は長さ「0」のスライスと同じように動作する
	fmt.Println(data, len(data), cap(data)) // [] 0 0

	fmt.Println(data == nil) // true

}

// ⅱ.次のように空のスライスリテラルを使ってスライスを生成することもできる
func EmptySlice() {

	x := []int{}

	// 長さ「0」のスライスが生成される
	// ☆☆☆　これはnilでは『ない』
	fmt.Println(x, len(x), cap(x)) // [] 0 0

	fmt.Println(x == nil) //false

}

// 📝 長さ「0」のスライスが有用なケースとしてはスライスをJSONに変換する場合がある
//
// ⅲ.初期値がある場合、あるいはスライスの値が変化しない場合は、次のようにスライスリテラルを使うのが良い
func SliceLiteral() {

	data := []int{2, 4, 6, 8}

	fmt.Println(data, len(data), cap(data)) // [2, 4, 6, 8] 4 4

}

// 実行してみればスライスのサイズがどのくらいになるか予想できるが、
// プログラムを書いている最中に分からない場合は「make」を使用する
//
// ☆　この場合、makeに正の長さを指定すべきか、あるいは長さ「0」にしてキャパシティを正の値にするべきか問題になる
// 　　次のようなケースが考えられる
//
// 1、バッファとしてスライスを用いる場合は、長さ(正の整数)をしていする
//
// 2、必要なサイズが正確にわかっている場合、そのサイズを指定する。
//
//	例えば、ひとつのスライスから別のスライスにデータを移す場合、以下の様な状況になる
//	サイズが間違っているとスライスの後ろの方にゼロ値が並んだり、存在しない要素にアクセスしようとしてパニックを起こしたりしてしまう
//
// 3、ほかの状況では "長さ「0」" でキャパシティ指定して「make」を実行する
//
//	スライスに要素を追加する場合は「append」を用いる
//	追加する要素が少ないと分かった場合でも、最後に余分なゼロ値が続かずに済む
//	そして、要素数が多くなった場合でもパニックは起らない
//
// ※ 2、3のアプローチではGoのコミュニティでも意見が分かれている
//
//	3は場合によっては実行が少し遅くなる可能性があるが、バグの危険が減る
//
// 📝 「append」は常にスライスの長さを大きくする
// 📝 「make」でスライスの正の長さ(n)を指定してから「append」すると、スライスの先頭からゼロ値がn個並んでしまうため、注意が必要
func FailMakeSliceAppend() {

	x := make([]int, 5)
	fmt.Println(x, len(x), cap(x)) // [0 0 0 0 0] 5 5

	x = append(x, 1, 2, 3, 4, 5)
	fmt.Println(x, len(x), cap(x)) // [0 0 0 0 0 1 2 3 4 5] 10 10

	// 「append」は要素を『追加』する
	// このようなパターンで無駄なゼロ値(上の例ではintのゼロ値「0」が並んでしまっている)

}

// ❐　スライスのスライス　❐
//
// スライスの部分を切り出して別のスライスを作る方法
//
// ========================================================================================
//
//	 ☆ 「スライス式(slice expression)」はスライスから別のスライスを作るためのもので、[n:m]の形式で書く
//		ここで、「n」が「開始オフセット」、「m」が終了オフセットになる
//		「n」を指定しないと「0」が仮定されるし、「m」を指定しないとスライスの最後が仮定される
//
// ========================================================================================
func SliceOfSlice() {

	x := []int{1, 2, 3, 4}
	fmt.Println(x, len(x), cap(x)) // [1 2 3 4] 4 4
	// index=>(0, 1, 2, 3)

	y := x[:2]                     // index=>(0, 1)  ※ x[:2] = x[0:2]
	fmt.Println(y, len(y), cap(y)) // [1 2] 2 4

	z := x[1:]                     // index=>(1, 2, 3)  ※ x[1:] = x[1:3]
	fmt.Println(z, len(z), cap(z)) // [2 3 4] 3 3

	d := x[1:3]                    // index=>(1, 2)
	fmt.Println(d, len(d), cap(d)) // [2 3] 2 3

	e := x[:]                      // index=>(0, 1, 2, 3) ※ x[:] = x[0:3]
	fmt.Println(e, len(e), cap(e)) // [1 2 3 4] 4 4

}

// ==================================================
// 「オフセット」とは位置を基準点から距離で表した値のこと
// ==================================================

// ❐ スライスの記憶領域の共有 ❐
//
// スライスからサブスライスを切り出す際には、『データのコピー』を作っているわけではない
// 2つの変数がメモリを共有している
// つまり、スライスの要素を変更すると、その要素を共有しているすべてのスライスが影響を受けることになる
func SubSliceShareMemory() {

	x := []int{1, 2, 3, 4}
	fmt.Println(x, len(x), cap(x)) // [1 2 3 4] 4 4

	y := x[:2]
	fmt.Println(y, len(y), cap(y)) // [1 2] 2 4

	z := x[1:]
	fmt.Println(z, len(z), cap(z)) // [2 3 4] 3 3

	// 「x」を変えると「y」も「z」も変わる
	// これに「append」を加えるとさらにややこしくなる
	y = append(y, 30)

	fmt.Println(x, len(x), cap(x)) // [1 2 3 4] 4 4  →  [1 2 30 4] 4 4

	fmt.Println(y, len(y), cap(y)) // [1 2] 2 4      →  [1 2 30] 3 4

}

// --------------------------------------------------------------------------------------
//
// ほかのスライスxを「スライスして」別のスライスyを作るとスライスyのキャパシティは「スライスxのキャパシティから(開始)オフセット分だけ引いたもの」に設定される
// ★ そして、スライスxで『使われなかったキャパシティ』もスライスyと共有されることになる
//
// 上記例で、スライスxからスライスyを作る時、長さは2に設定されるが、キャパシティは4に設定される(☆ スライスxと同じ)
// キャパシティは4なのでスライスyの終わりにappendすると、xの3番目の位置に追加される
//
// --------------------------------------------------------------------------------------
//
// このようなことをすると、とても奇妙なことになる
// 複数のスライスが他のスライスのデータをappendしたり上書きしたりしてしまう
func MultiSubSliceAppendComplex() {

	x := make([]int, 0, 5)
	fmt.Println(x, len(x), cap(x)) // [] 0 5

	x = append(x, 1, 2, 3, 4)
	fmt.Println(x, len(x), cap(x)) // [1 2 3 4] 4 5

	y := x[:2]
	fmt.Println(y, len(y), cap(y)) // [1 2] 2 5

	z := x[2:]
	fmt.Println(z, len(z), cap(z)) // [3 4] 2 3

	fmt.Println(cap(x), cap(y), cap(z)) //「cap(x) => 5」「cap(y) => 5」「cap(z) => 3」

	y = append(y, 30, 40, 50)
	fmt.Println(y, len(y), cap(y)) // [1 2 30 40 50] 5 5

	x = append(x, 60)
	fmt.Println(x, len(x), cap(x)) // [1 2 30 40 60] 5 5　※「y」が共有しているのはxの[1 2 3 4]だけ、そのため、yの「50」の影響は受けない

	z = append(z, 70)
	fmt.Println(z, len(z), cap(z)) // [30 40 70] 3 3

}

// こうしたスライスに関する複雑な状況を避けるため、サブスライスについては「append」を使わないようにするか、
// 『フルスライス式』を用いてappendでは上書きが生じないようにする
//
// ☆☆☆ フルスライス式ではサブスライスに対して「利用できる親スライスのキャパシティの最後の位置」を指定する（サブスライスの終了オフセットを指定する）
//
//	サブスライスのキャパシティを得るには、この数値から『開始』オフセットを引く
//
// 少し奇妙な感じがするかもしれないが、こうすることで親スライスとサブスライスの間でどのようにメモリが共有されるかが明確になる
func FullSlice() {

	x := make([]int, 0, 5)
	fmt.Println(x, len(x), cap(x)) // [] 0 5

	x = append(x, 1, 2, 3, 4)
	fmt.Println(x, len(x), cap(x)) // [1 2 3 4] 4 5

	y := x[:2:2] // フルスライス式
	//
	fmt.Println(y, len(y), cap(y)) // [1 2] 2 2

	z := x[2:4:4] // フルスライス式
	//
	fmt.Println(z, len(z), cap(z)) // [3 4] 2 2

}

// サブスライスを作成した時点のyとzのキャパシティはいずれも2になる（フルスライス式で利用できる親スライスのキャパシティの最後の位置を指定したから）
// サブスライスのキャパシティとサブスライスの長さを同じにしたため、yやzに要素を追加すると、ほかのスライスと『共有することなし』に新しいスライスが作られる
//
// ※ スライスをスライスする(スライスからサブスライスを切り出す)ときは十分に注意すること
// 　 親スライスもサブスライスも同じメモリ領域を共有し、一方の変更は『もう一方に影響を及ぼす』
// 　 サブスライスを作ったらオリジナルのスライスもサブスライスも変更を避けた方が無難
// 　 「append」では、複数のスライスがキャパシティを共有しないようフルスライス式を使用する

// ❐　配列からスライスへの変換　❐
//
// 「スライス」できるのはスライスだけではない
// 配列についても、スライス式を使ってスライスを作れる
// スライスを引数にとる関数に配列を渡したい場合にこの機能を使える
// ★しかし、配列からスライスを作る時もスライスからサブスライスを作る時と同じメモリ共有の問題が起こる
func ArraySlice() {

	x := [...]int{5, 6, 7, 8}      // 配列を生成
	fmt.Println(x, len(x), cap(x)) // [5 6 7 8] 4 4

	y := x[:2]
	fmt.Println(y, len(y), cap(y)) // [5 6] 2 4

	z := x[2:]
	fmt.Println(z, len(z), cap(z)) // [7 8] 2 2

	d := x[:]
	fmt.Println(d, len(d), cap(d)) // [5 6 7 8] 4 4

	x[0] = 10

	fmt.Println(x, len(x), cap(x)) // [10 6 7 8] 4 4
	fmt.Println(y, len(y), cap(y)) // [10 6] 2 4
	fmt.Println(z, len(z), cap(z)) // [7 8] 2 2
	fmt.Println(d, len(d), cap(d)) // [10 6 7 8] 4 4

}

// ❐ メモリを共有しないスライスのコピー ❐
//
// オリジナルとはメモリを共有しない独立したスライスを生成する必要があるのならば、「make」と組み込み関数の「copy」を使う
func CopySlice() {
	x := []int{1, 2, 3, 4} // オリジナルのスライス
	fmt.Println(x, len(x), cap(x)) // [1 2 3 4] 4 4

	y := make([]int, 4) // 長さ4のintのゼロ値のスライス
	fmt.Println(y, len(y), cap(y)) // [0 0 0 0] 4 4

	num := copy(y, x) // 「x」から「y」にコピーする　※戻り値はコピーされた要素数、つまり変数「num」には「4」が代入されている
	fmt.Println(y, num) // [1 2 3 4] 4

}
//
// 関数「copy」の引数は2つ
// ・第1引数はターゲットのスライス
// ・第2引数がソース(コピー元)のスライス
//
// ★ ソースからターゲットへ『出来る限り』値をコピーする
// ☆ スライスのほうが小さければスライスの長さまでコピーされる
// ★ 戻り値はコピーされた要素数になる
// ☆☆☆ 「x」や「y」のキャパシティは関係なく、『長さ』が重要になる
//
//
// いつもスライス全体をコピーする必要はない
// 次のコードは4つの要素を持つスライスの内、先頭の2つの要素を(2つの要素を持つ)スライスにコピーする
func CopyPeaceOfSlice() {

	x := []int{1, 2, 3, 4}
	fmt.Println(x, len(x), cap(x)) // [1 2 3 4] 4 4

	y := make([]int, 2)
	fmt.Println(y, len(y), cap(y)) // [0 0] 2 2

	num := copy(y, x)
	fmt.Println(y, num) // [1 2] 2

}